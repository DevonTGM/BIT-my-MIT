<div id="bitmymit"></div>
<script>
    (() => {
        const mount = document.getElementById("bitmymit");
        if (!mount) return;

        // ensure the widget sits above page content if needed
        mount.style.position = "relative";
        mount.style.zIndex = "9999";

        const links = {
            quiz: "https://lexue.bit.edu.cn/mod/hvp/view.php?id=514901",
            pdf: "https://lexue.bit.edu.cn/pluginfile.php/761257/mod_resource/content/1/AI%20Overview%20Study%20Guide.pdf?forcedownload=1",
            files: "https://lexue.bit.edu.cn/mod/folder/view.php?id=512418"
        };

        // remove previously injected widget (safety)
        const prev = mount.querySelector('.bitmymit-root');
        if (prev) prev.remove();

        // build DOM
        const root = document.createElement('div');
        root.className = 'bitmymit-root';
        root.innerHTML = `
  <div class="bm-container">
    <!-- HERO -->
    <section class="hero">
      <canvas class="hero-canvas" aria-hidden="true"></canvas>
      <div class="hero-content">
        <h1 class="title">BITmyMIT <span class="droplet">üí¶</span></h1>
        <p class="tagline">"If we can learn AI, you can too."</p>
        <p class="sub">AI Overview ¬∑ Interactive Learning ¬∑ Knowledge for Everyone</p>
      </div>
    </section>

    <!-- CARDS -->
    <section class="cards-section">
      <div class="grid">
        <a class="card" href="${links.quiz}" target="_blank" data-tilt>
          <div class="card-inner">
            <div class="icon bubble-purple">üß†</div>
            <h3>Interactive Quiz</h3>
            <p>Practice & learn through guided questions.</p>
          </div>
        </a>

        <a class="card" href="${links.pdf}" target="_blank" data-tilt>
          <div class="card-inner">
            <div class="icon bubble-blue">üìò</div>
            <h3>Study Guide (PDF)</h3>
            <p>Our summary, explanations & diagrams.</p>
          </div>
        </a>

        <a class="card" href="${links.files}" target="_blank" data-tilt>
          <div class="card-inner">
            <div class="icon bubble-peach">üìÇ</div>
            <h3>Slides + Materials</h3>
            <p>Access everything in one place.</p>
          </div>
        </a>

        <div class="card muted" data-tilt>
          <div class="card-inner">
            <div class="icon bubble-gray">üíª</div>
            <h3>GitHub (soon)</h3>
            <p>We're still polishing our repo!</p>
          </div>
        </div>

        <div class="card muted" data-tilt>
          <div class="card-inner">
            <div class="icon bubble-pink">üé¨</div>
            <h3>Video (soon)</h3>
            <p>Editing in progress üéûÔ∏è stay tuned!</p>
          </div>
        </div>
      </div>
    </section>

    <p class="footer">Made with üí¶ by Mikhael ¬∑ Andrey ¬∑ Kenrich ¬∑ Dmitrii ¬∑ Arina ¬∑ Alina</p>
  </div>
  `;
        mount.appendChild(root);

        // Remove any previously injected styles for safety
        Array.from(document.head.querySelectorAll('style')).forEach(s => {
            if (s.textContent && s.textContent.includes('.bitmymit-root')) s.remove();
        });

        // CSS scoped to widget
        const css = `
  /* ---------- BITmyMIT WIDGET (scoped) ---------- */
  .bitmymit-root { box-sizing: border-box; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }

  /* container keeps the widget narrow and centered in its section */
  .bm-container {
    max-width: 1024px;
    margin: 0 auto;
    padding: 18px 12px;
  }

  /* page-ish background inside the widget only (won't touch body) */
  .bitmymit-root { --bg1: #F6FAFF; --bg2: #E9F1FF; --accent-cyan: #00C9FF; --accent-purple: #7D5CFF; --glass-white: rgba(255,255,255,0.14); --text-dark: #0F172A; --text-light: #eef4ff; }

  /* overall widget background (subtle) */
  .bitmymit-root { background: linear-gradient(135deg, var(--bg1), var(--bg2), #ffffff); border-radius: 12px; padding: 10px; }

  /* -------- HERO (dark banner) -------- */
  .hero {
    position: relative;
    overflow: hidden;
    border-radius: 14px;
    padding: 56px 18px;
    margin-bottom: 22px;
    min-height: 200px;
    display:flex;
    align-items:center;
    justify-content:center;
    background: linear-gradient(135deg,#0e1a2b,#1a2f49 40%,#253b67);
    color: var(--text-light);
    box-shadow: 0 12px 34px rgba(6,10,14,0.45);
  }

  .hero-content { position: relative; z-index: 8; text-align:center; max-width: 860px; padding: 6px 12px; }

  .title {
    font-weight: 800;
    font-size: clamp(28px, 5.4vw, 56px);
    line-height: 1.02;
    letter-spacing: -0.02em;
    margin: 0;
    background: linear-gradient(90deg, var(--accent-cyan), var(--accent-purple));
    -webkit-background-clip: text;
    color: transparent;
    text-shadow: 0 10px 30px rgba(21,30,46,0.25);
  }

  .droplet { margin-left: 8px; display: inline-block; transform: translateY(-3px); filter: drop-shadow(0 6px 12px rgba(0,0,0,0.45)); }

  .tagline { margin-top: 8px; color: rgba(215,230,255,0.95); font-weight:600; font-size:15px; }
  .sub { margin-top: 6px; color: rgba(215,230,255,0.75); font-size:13.5px; }

  /* subtle layered vignette behind hero (dark, not bright) */
  .hero::before {
    content: "";
    position: absolute;
    inset: 0;
    background:
      radial-gradient(900px 360px at 16% 34%, rgba(125,92,255,0.06), transparent 12%),
      radial-gradient(650px 260px at 84% 40%, rgba(0,201,255,0.04), transparent 10%);
    filter: blur(14px) saturate(110%);
    z-index: 2;
    pointer-events: none;
  }

  /* hero canvas sits below content for particles */
  .hero-canvas { position: absolute; inset: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }

  /* -------- CARDS (glass + pop + tilt) -------- */
  .cards-section { margin-top: 6px; }
  .grid {
    display: grid;
    gap: 18px;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    align-items: stretch;
  }

  .card {
    display: block;
    text-decoration: none;
    color: inherit;
    border-radius: 12px;
    transition: transform 220ms cubic-bezier(.2,.9,.2,1);
    will-change: transform;
  }

  .card-inner {
    background: var(--glass-white);
    border-radius: 12px;
    padding: 18px;
    min-height: 140px;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    border:1px solid rgba(255,255,255,0.08);
    box-shadow: 0 8px 22px rgba(6,10,14,0.14);
    transition: box-shadow 220ms ease, transform 220ms ease, backdrop-filter 220ms ease;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }

  /* hover lift + glow */
  .card-inner:hover {
    transform: translateY(-10px) scale(1.02);
    box-shadow: 0 28px 60px rgba(6,10,14,0.36), 0 4px 12px rgba(0,201,255,0.04);
    backdrop-filter: blur(18px);
  }

  .icon {
    width:56px; height:56px; border-radius:50%;
    display:flex; align-items:center; justify-content:center;
    font-size:22px; margin-bottom:12px;
    transition: transform 180ms ease, box-shadow 180ms ease;
    box-shadow: 0 8px 18px rgba(0,0,0,0.18);
  }
  .card-inner:hover .icon { transform: translateY(-6px); box-shadow: 0 18px 36px rgba(0,0,0,0.36), 0 0 18px rgba(125,92,255,0.06); }

  .card h3 { margin: 6px 0 8px; font-size:18px; color: var(--text-dark, #eef4ff); text-align:center; }
  .card p { margin: 0; font-size:13.5px; color: rgba(20,26,34,0.86); text-align:center; }

  .muted { opacity: 0.88; }

  /* color bubbles */
  .bubble-purple { background: rgba(125,92,255,0.16); }
  .bubble-blue   { background: rgba(0,201,255,0.14); }
  .bubble-peach  { background: rgba(255,204,157,0.12); }
  .bubble-gray   { background: rgba(220,225,235,0.06); }
  .bubble-pink   { background: rgba(255,180,220,0.12); }

  /* footer */
  .footer { margin-top: 18px; text-align:center; color: rgba(20,30,44,0.6); font-size:13px; }

  /* responsive */
  @media (max-width: 720px) {
    .bm-container { padding: 12px; }
    .hero { padding: 36px 12px; min-height: 150px; }
    .title { font-size: clamp(20px, 8vw, 36px); }
  }
  `;

        const style = document.createElement('style');
        style.textContent = css;
        document.head.appendChild(style);

        /* ================= CANVAS PARTICLES (scoped to hero) ================= */
        const canvas = root.querySelector('.hero-canvas');
        const ctx = canvas && canvas.getContext ? canvas.getContext('2d') : null;
        let dpr = window.devicePixelRatio || 1;
        let w = 0,
            h = 0,
            particles = [],
            raf = null;

        function resizeCanvas() {
            if (!canvas || !ctx) return;
            dpr = window.devicePixelRatio || 1;
            w = canvas.width = canvas.clientWidth * dpr;
            h = canvas.height = canvas.clientHeight * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function createParticles() {
            particles = [];
            if (!canvas) return;
            const count = Math.max(10, Math.floor(canvas.clientWidth / 90));
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: Math.random() * canvas.clientWidth,
                    y: Math.random() * canvas.clientHeight,
                    r: 1 + Math.random() * 3,
                    v: 0.1 + Math.random() * 0.45,
                    alpha: 0.04 + Math.random() * 0.14
                });
            }
        }

        function drawParticles() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
            particles.forEach(p => {
                p.y -= p.v;
                if (p.y < -10) {
                    p.y = canvas.clientHeight + 10;
                    p.x = Math.random() * canvas.clientWidth;
                }
                const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 8);
                grad.addColorStop(0, `rgba(125,92,255,${p.alpha})`);
                grad.addColorStop(0.6, `rgba(0,201,255,${p.alpha * 0.45})`);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.beginPath();
                ctx.fillStyle = grad;
                ctx.arc(p.x, p.y, p.r * 4, 0, Math.PI * 2);
                ctx.fill();
            });
            raf = requestAnimationFrame(drawParticles);
        }

        function initParticles() {
            if (!ctx) return;
            resizeCanvas();
            createParticles();
            if (raf) cancelAnimationFrame(raf);
            drawParticles();
        }

        // observe hero size
        const hero = root.querySelector('.hero');
        const ro = new ResizeObserver(() => {
            resizeCanvas();
            createParticles();
        });
        ro.observe(hero);
        initParticles();

        /* ================ mouse-follow spotlight (scoped) ================ */
        function onHeroMouseMove(e) {
            const rect = hero.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            hero.style.setProperty('--x', x + 'px');
            hero.style.setProperty('--y', y + 'px');
        }
        hero.addEventListener('mousemove', onHeroMouseMove);
        hero.addEventListener('mouseleave', () => {
            hero.style.setProperty('--x', (hero.clientWidth / 2) + 'px');
            hero.style.setProperty('--y', (hero.clientHeight / 2) + 'px');
        });
        // set center initially
        hero.style.setProperty('--x', (hero.clientWidth / 2) + 'px');
        hero.style.setProperty('--y', (hero.clientHeight / 2) + 'px');

        /* ================ 3D tilt for cards ================ */
        function applyTilt(inner, e) {
            const rect = inner.getBoundingClientRect();
            const px = (e.clientX - rect.left) / rect.width;
            const py = (e.clientY - rect.top) / rect.height;
            const rx = (py - 0.5) * -6;
            const ry = (px - 0.5) * 10;
            inner.style.transform = `translateZ(0) rotateX(${rx}deg) rotateY(${ry}deg)`;
        }

        function resetTilt(inner) {
            inner.style.transform = '';
        }

        const tiltEls = root.querySelectorAll('[data-tilt]');
        tiltEls.forEach(card => {
            const inner = card.querySelector('.card-inner');
            if (!inner) return;
            card.addEventListener('mousemove', (e) => applyTilt(inner, e));
            card.addEventListener('mouseleave', () => {
                inner.style.transition = 'transform 220ms ease';
                resetTilt(inner);
                setTimeout(() => inner.style.transition = '', 240);
            });
            card.addEventListener('mouseenter', () => {
                inner.style.transition = 'transform 120ms';
                setTimeout(() => inner.style.transition = '', 160);
            });
        });

        /* ================ reduced-motion support ================ */
        const rm = window.matchMedia('(prefers-reduced-motion: reduce)');
        if (rm.matches) {
            // stop particle animation & remove mouse listeners
            particles = [];
            if (raf) {
                cancelAnimationFrame(raf);
                raf = null;
            }
            hero.removeEventListener('mousemove', onHeroMouseMove);
            tiltEls.forEach(card => {
                const inner = card.querySelector('.card-inner');
                if (!inner) return;
                card.removeEventListener('mousemove', (e) => applyTilt(inner, e));
            });
        }

        /* ================ intersection observer: pause when not visible ================ */
        const io = new IntersectionObserver(entries => {
            entries.forEach(en => {
                if (en.isIntersecting) {
                    if (!particles.length) createParticles();
                    if (!raf) drawParticles();
                } else {
                    if (raf) {
                        cancelAnimationFrame(raf);
                        raf = null;
                    }
                }
            });
        }, {
            threshold: 0.05
        });
        io.observe(hero);

    })();
</script>
